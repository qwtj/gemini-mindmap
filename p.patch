--- a/mind_map_force_layout_v3.html
+++ b/mind_map_force_layout_v3.html
@@ -60,6 +60,11 @@
             stroke: #4338ca; /* indigo-700 */
             stroke-width: 3px;
         }
+        .node.drop-target rect {
+            stroke: #22c55e; /* green-500 */
+            stroke-width: 4px;
+            stroke-dasharray: 8 4;
+        }
         .node.dragging {
             cursor: grab;
         }
@@ -291,6 +296,7 @@
                 </li>
                 <li><strong>Canvas Interaction:</strong>
                     <ul>
+                        <li>- Drag one node on top of another to make it a child of that node.</li>
                         <li>- Click and drag any node to reposition it. The other nodes will react and move to avoid collisions. A dragged node will stay where you leave it.</li>
                         <li>- Use your mouse wheel or trackpad to zoom. Click and drag the background to pan the view.</li>
                     </ul>
@@ -481,6 +487,7 @@
         let selectedNodes = [];
         let activeParentForInsertion = null;
         let previousActiveElement;
+        let potentialDropTarget = null;
         
         // --- Force Simulation State ---
         let isForceActive = true;
@@ -1112,65 +1119,141 @@
             }
         }
         
+        // --- Helper for Drag & Drop ---
+        function findDropTarget(draggedNode) {
+            let target = null;
+            const { x: draggedX, y: draggedY } = draggedNode;
+
+            // Find the node we are hovering over
+            for (const n of allNodes) {
+                // Exclude self and parent from being drop targets
+                if (n === draggedNode || n === draggedNode.parent) {
+                    continue;
+                }
+                // Prevent dropping a node onto one of its own descendants
+                if (n.ancestors().includes(draggedNode)) {
+                    continue;
+                }
+                
+                const isOver = draggedX > n.x - n.width / 2 &&
+                       draggedX < n.x + n.width / 2 &&
+                       draggedY > n.y - n.height / 2 &&
+                       draggedY < n.y + n.height / 2;
+
+                if (isOver) {
+                    target = n;
+                    break; // Found a target, no need to check others
+                }
+            }
+            return target;
+        }
+
         // --- Drag & Drop Handlers ---
         function dragstarted(event, d) {
             if (event.sourceEvent.target.closest('.add-child-button')) {
                 d.isButtonClick = true;
                 return;
             }
             d.isButtonClick = false;
             if (isForceActive && !event.active) simulation.alphaTarget(0.3).restart();
+            d.dragStartX = event.x;
+            d.dragStartY = event.y;
             d.fx = d.x;
             d.fy = d.y;
             d3.select(this).raise().classed("dragging", true);
+            potentialDropTarget = null; // Reset on new drag
         }
 
         function dragged(event, d) {
             if (d.isButtonClick) return;
             d.fx = event.x;
             d.fy = event.y;
+
+            // New drop target detection logic
+            const currentTarget = findDropTarget(d);
+            
+            if (potentialDropTarget && potentialDropTarget !== currentTarget) {
+                d3.select(`a.node[data-id="${potentialDropTarget.data._id}"]`).classed('drop-target', false);
+            }
+
+            potentialDropTarget = currentTarget;
+            
+            if (potentialDropTarget) {
+                d3.select(`a.node[data-id="${potentialDropTarget.data._id}"]`).classed('drop-target', true);
+            }
+
             if(!isForceActive) {
                 d.x = d.fx;
                 d.y = d.fy;
                 ticked();
             }
         }
-
+        
         async function dragended(event, d) {
             if (d.isButtonClick) {
                 delete d.isButtonClick;
                 return;
             }
-
+        
             if (isForceActive && !event.active) simulation.alphaTarget(0);
             d3.select(this).classed("dragging", false);
-
-            const dist = Math.hypot(event.x - d.dragStartX, event.y - d.dragStartY);
-            
-            if (dist > 5) { // It was a drag
-                 const nodeData = await idb.get(d.data._id);
-                 nodeData.fx = d.fx;
-                 nodeData.fy = d.fy;
-                 await idb.set(nodeData);
-            } else { // It was a click
-                d.fx = null;
-                d.fy = null;
-                 const nodeData = await idb.get(d.data._id);
-                 nodeData.fx = null;
-                 nodeData.fy = null;
-                 await idb.set(nodeData);
-
-                if (isForceActive) simulation.alpha(1).restart();
+            
+            if (potentialDropTarget) {
+                d3.select(`a.node[data-id="${potentialDropTarget.data._id}"]`).classed('drop-target', false);
+            }
+        
+            if (potentialDropTarget) {
+                const oldParent = d.parent;
+                const newParent = potentialDropTarget;
+        
+                if (oldParent) {
+                    oldParent.data.children = oldParent.data.children.filter(child => child._id !== d.data._id);
+                    if (oldParent.data.children.length === 0) oldParent.data.children = null;
+                } else {
+                    roots = roots.filter(r => r.data._id !== d.data._id);
+                }
+        
+                if (!newParent.data.children) newParent.data.children = [];
+                newParent.data.children.push(d.data);
+        
+                d.fx = null;
+                d.fy = null;
+                const nodeData = await idb.get(d.data._id);
+                nodeData.fx = null;
+                nodeData.fy = null;
+                await idb.set(nodeData);
+        
+                await update();
+            } else {
+                const dist = Math.hypot(event.x - d.dragStartX, event.y - d.dragStartY);
                 
-                // Handle click selection logic
-                if (multiSelectMode || event.sourceEvent.shiftKey) {
-                    const index = selectedNodes.findIndex(n => n.data._id === d.data._id);
-                    if (index > -1) selectedNodes.splice(index, 1);
-                    else selectedNodes.push(d);
-                } else {
-                    selectedNodes = [d];
+                if (dist > 5) {
+                     const nodeData = await idb.get(d.data._id);
+                     nodeData.fx = d.fx;
+                     nodeData.fy = d.fy;
+                     await idb.set(nodeData);
+                } else {
+                    d.fx = null;
+                    d.fy = null;
+                     const nodeData = await idb.get(d.data._id);
+                     nodeData.fx = null;
+                     nodeData.fy = null;
+                     await idb.set(nodeData);
+        
+                    if (isForceActive) simulation.alpha(1).restart();
+                    
+                    if (multiSelectMode || event.sourceEvent.shiftKey) {
+                        const index = selectedNodes.findIndex(n => n.data._id === d.data._id);
+                        if (index > -1) selectedNodes.splice(index, 1);
+                        else selectedNodes.push(d);
+                    } else {
+                        selectedNodes = [d];
+                    }
+                    nodeGroup.selectAll("a.node").classed("selected", n => selectedNodes.some(sn => sn.data._id === n.data._id));
+                    const nodeToFocus = this;
+                    setTimeout(() => nodeToFocus.focus(), 0);
                 }
-                nodeGroup.selectAll("a.node").classed("selected", n => selectedNodes.some(sn => sn.data._id === n.data._id));
-                const nodeToFocus = this;
-                setTimeout(() => nodeToFocus.focus(), 0);
-            }
-            delete d.dragStartX;
-            delete d.dragStartY;
+            }
+        
+            potentialDropTarget = null;
+            delete d.dragStartX;
+            delete d.dragStartY;
         }
 
         // --- Keyboard Handlers ---
